# Тема 4. Функции и модули
Отчет по Теме #4 выполнил(а):
- Зернаев Роман Денисович
- ИВТ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |
| Задание 6 | + | 
| Задание 7 | + | 
| Задание 8 | + | 
| Задание 9 | + | 
| Задание 10 |+ |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Напишите функцию, которая выполняет любые арифметические
действия и выводит результат в консоль. Вызовите функцию используя
“точку входа”

```python
def main():
    print(2+2)


if __name__ == '__main__':
    main()
```
### Результат.
![image](https://github.com/user-attachments/assets/a2096176-813a-444d-b8c5-06129776a947)

Выводы:
1. Этот скрипт демонстрирует базовую структуру программы на Python с использованием функции и специальной проверки if __name__ == '__main__':.
2. Результат выполнения этого кода - вывод числа 4 в консоль.
3. Структура if __name__ == '__main__': используется для предотвращения автоматического выполнения кода при импорте этого скрипта как модуля в другие программы.

## Лабораторная работа №2
### Напишите функцию, которая выполняет любые арифметические
действия, возвращает при помощи return значение в место, откуда
вызывали функцию. Выведите результат в консоль. Вызовите функцию
используя “точку входа”

```python
def main():
    return 2+2


if __name__ == '__main__':
    print(main())
```
```python
def main():
    result = 2 + 2
    return result


if __name__ == '__main__':
    answer = main()
    print(answer)
```
### Результат.
![image](https://github.com/user-attachments/assets/e880e540-b3df-4260-be66-63cc3d3d732f)

## Выводы
1. Эта программа возвращает результат сложения 2 + 2 из функции main() и затем выводит его с помощью print(). Итоговый вывод программы в консоль — число 4.
2. Использование return в функции main() позволяет вернуть результат вычисления, который затем можно использовать в других частях программы.
3. Условие if __name__ == '__main__': обеспечивает запуск функции только при непосредственном выполнении скрипта, что предотвращает его автоматическое выполнение при импорте в другие модули.

## Лабораторная работа №3
### Напишите функцию, в которую передаются два аргумента, над ними
производится арифметическое действие, результат возвращается туда,
откуда эту функцию вызывали. Выведите результат в консоль.
Вызовите функцию в любом небольшом цикле

```python
def main(one, two):
    result = one + two
    return result


for i in range(5):
    x = 1
    y = 10
    answer = main(x, y)
    print(answer)
```
```python
def main(one, two):
    return one + two


for i in range(5):
    answer = main(one = 1, two = 10)
    print(answer)
```
### Результат.
![image](https://github.com/user-attachments/assets/1e25d603-e603-43ee-8a99-5e08a416eaf3)

## Выводы
1. В первой программе, в которой аргумент
функции “x“превращается в параметр “one”, то же самое происходит
с “y” и “two”
2. Во второй программе, как и в прошлой, только
аргументы передаются в вызове функции, а не как отдельные
переменные

## Лабораторная работа №4
### Напишите функцию, на вход которой подается какое-то изначальное
неизвестное количество аргументов, над которыми будет производится
арифметические действия. Для выполнения задания необходимо
использовать кортеж “*args”. На скриншоте ниже приведен пример
такой программы с комментариями.
Для закрепления понимания работы с кортежами настоятельно
рекомендуем поменять аргументы вызова функции, вручную посчитать
результат, только потом запустить программу с новыми значениями и
проверить себя, насколько вы поняли данный аспект
программирования.

```python
def main(x, *args):
    one = x
    two = sum(args)
    three = float(len(args))
    print(f"one={one}\ntwo={two}\nthree={three}")
    
    return x + sum(args) / float(len(args))

if __name__ == '__main__':
    result = main(10, 0, 1, 2, -1, 0, -1, 1, 2)
    print(f"\nresult={result}")
```

### Результат.
![image](https://github.com/user-attachments/assets/6b1bca79-c2e5-4b4e-9e48-e144b0a3ae35)

## Выводы
1. Функция main принимает первый аргумент x и произвольное количество дополнительных аргументов *args.
2. Переменная one хранит значение первого аргумента x.
3. Переменная two содержит сумму всех элементов из *args.
4. Переменная three хранит количество переданных дополнительных аргументов, преобразованное в float.
5. Функция выводит значения x, сумму элементов *args, и количество этих элементов.
6. Функция возвращает результат, представляющий собой сумму x и среднего значения элементов в *args.
7. В примере вызова main(10, 0, 1, 2, -1, 0, -1, 1, 2):
x равен 10.
*args содержит (0, 1, 2, -1, 0, -1, 1, 2).
8. Код показывает, как работать с переменным количеством аргументов, вычислять сумму и среднее значение.

## Лабораторная работа №5
### Напишите функцию, которая на вход получает кортеж “**kwargs” и
при помощи цикла выводит значения, поступившие в функцию. На
скриншоте ниже указаны два варианта вызова функции с “**kwargs” и
два варианта работы с данными, поступившими в эту функцию.
Комментарии в коде и теоретическая часть помогут вам разобраться в
этом нелегком аспекте. Вызовите функцию используя “точку входа”

```python
def main(**kwargs):
    for i in kwargs.items():
        print(i[0], i[1])
        
    print()
    
    for key in kwargs:
        print(f"{key} = {kwargs[key]}")
        
        
if __name__ == '__main__':
    main(x=[1, 2, 3], y=[3, 3, 0], z=[2, 3, 0], q=[3, 3, 0], w=[3, 3, 0])
    print()
    main(**{'x': [1, 2, 3], 'y': [3, 3, 0]})
```
### Результат.
![image](https://github.com/user-attachments/assets/fffd4081-1ab2-4aee-be20-0aef6a197827)

## Выводы
1. Функция main принимает именованные аргументы как словарь kwargs.
2. Первый цикл выводит пары "ключ значение", второй — в формате "ключ = значение".
3. Первый вызов main создает словарь из пяти элементов (x, y, z, q, w) и выводит их.
4. Второй вызов распаковывает словарь с двумя элементами и передает их в функцию.
5. Код показывает, как использовать **kwargs для работы с переменным числом именованных аргументов и два способа их вывода.

## Лабораторная работа №6
### Напишите две функции. Первая – получает в виде параметра
“**kwargs”. Вторая считает среднее арифметическое из значений
первой функции. Вызовите первую функцию используя “точку входа”
и минимум 4 аргумента.

```python
def main(**kwargs):
    
    
    for i, j in kwargs.items():
        print(f"{i}. Mean = {mean(j)}")
        
        
def mean(data):
    
    
    return sum(data) / float(len(data))


if __name__ == '__main__':
    main(**{'x': [1, 2, 3], 'y':[3, 3, 0], 'z':[3, 3, 3], 'q': [5, 2, 5]})
```
### Результат.
![image](https://github.com/user-attachments/assets/35157b30-fdff-49fc-9b51-44758392ac7d)

## Выводы
1. main вычисляет средние значения для каждого переданного списка.
2. mean возвращает среднее значение списка.
3. Функция демонстрирует работу с именованными аргументами и их обработку.

## Лабораторная работа №7
### Создайте дополнительный файл .py. Напишите в нем любую функцию,
которая будет что угодно выводить в консоль, но не вызывайте ее в
нем. Откройте файл main.py, импортируйте в него функцию из нового
файла и при помощи “точки входа” вызовите эту функцию.

```python
def say_hello():
    print('Hello students!')
```
```python
from lab_rb7 import say_hello

if __name__ == '__main__':
    say_hello()
```
### Результат.
![image](https://github.com/user-attachments/assets/c167573f-eaeb-49ee-8e10-658fa7aff75b)
![image](https://github.com/user-attachments/assets/05cba440-0930-44d5-a3d6-eda1fe28fc37)
![image](https://github.com/user-attachments/assets/4e6fdf35-a1ee-4f4d-bc01-15311c0953e7)

## Выводы
1. Одна программа определяет функцию say_hello() и может быть использована как самостоятельный модуль (lab_rb7.py).
2. Другая программа импортирует эту функцию из модуля lab_rb7 и вызывает ее, демонстрируя принцип переиспользования кода.
3. Импорт перезаписывает локальное определение функции, показывая, что импортируемые функции заменяют одноименные локальные функции.
4. Использование if __name__ == '__main__': позволяет запускать код только при непосредственном выполнении файла, предотвращая выполнение при импорте.

## Лабораторная работа №8
### Напишите программу, которая будет выводить корень, синус, косинус
полученного от пользователя числа

```python
import math


def main():
    value = int(input('Введите значения: '))
    print(math.sqrt(value))
    print(math.sin(value))
    print(math.cos(value))
    
    
if __name__ == '__main__':
    main()
```
```python
from math import sqrt, sin, cos


def main():
    value = int(input('Введите значения: '))
    print(sqrt(value))
    print(sin(value))
    print(cos(value))
    
    
if __name__ == '__main__':
    main()
```
```python
from math import *


def main():
    value = int(input('Введите значения: '))
    print(sqrt(value))
    print(sin(value))
    print(cos(value))
    
    
if __name__ == '__main__':
    main()
```
### Результат.
![image](https://github.com/user-attachments/assets/9a889441-5bbc-4f4a-bfa0-80f15d311e6c)

## Выводы
1. На первом скриншоте мы просто импортировали модуль math целиком
и вызвали его длинным способом через math.название_фунции.
Также импорт стандартного модуля в python возможно осуществить и
другими способами, которые будут выполнять ту же самую функцию,
но синтаксис будет немного отличатся.
2. На втором скриншоте из модуля math мы загрузили в программу
только 3 необходимые функции и обращались к ним так, будто они 
находятся у нас в файле просто через их название. Также замечу что
мы импортировали три функции в одну строку, что очень удобно.
3. На третьем скриншоте мы импортировали модуль math и при помощи
оператора * загрузили все его функции. По большому счеты мы
сделали то же самое что и на первом скриншоте, но у нас только
поменялся синтаксис вызова этих функций, он стал похож на вызов со
второго скриншота

## Лабораторная работа №9
### Напишите программу, которая будет рассчитывать какой день недели
будет через n-нное количество дней, которые укажет пользователь.

```python
from datetime import datetime as dt
from datetime import timedelta as td



def main():
    print(
        f"Сегодня {dt.today().date()}. "
        f"День недели - {dt.today().isoweekday()}"
    )
    n = int(input('Введите количество дней: '))
    today = dt.today()
    result = today + td(days=n)
    print(
        f"Через {n} дней будет {result.date()}. "
        f"день недели - {result.isoweekday()}"
    )
    
    
if __name__ == '__main__':
    main()
```
### Результат.
![image](https://github.com/user-attachments/assets/849d50dd-30ea-4313-9d6c-2830246374e5)

## Выводы
1. Программа использует модули datetime и timedelta для работы с датами.
2. Выводит текущую дату и день недели.
3. Запрашивает у пользователя количество дней и вычисляет дату, которая наступит через это количество дней.
4. Выводит новую дату и соответствующий день недели.
5. Демонстрирует работу с датой, временем и пользовательским вводом в Python.

## Лабораторная работа №10
### Напишите программу с использованием глобальных переменных,
которая будет считать площадь треугольника или прямоугольника в
зависимости от того, что выберет пользователь. Получение всей
необходимой информации реализовать через input(), а подсчет
площадей выполнить при помощи функций. Результатом программы будет число, 
равное площади, необходимой фигуры.

```python
global result


def rectangle():
    a = float(input('Ширина: '))
    b = float(input('Высота: '))
    global result
    result = a * b
    
    
def triangle():
    a = float(input('Основание: '))
    h = float(input('Высота: '))
    global result
    result = 0.5 * a * h
    
    
figure = input("1 - прямоуголник, 2 - треугольник: ")
    
if figure == '1':
    rectangle()
elif figure == '2':
    triangle()
    
print(f"Площадь: {result}")
```
### Результат.
![image](https://github.com/user-attachments/assets/b85c8dbf-2d06-46ea-ae93-3061af494dea)

## Выводы
1. Программа вычисляет площадь прямоугольника или треугольника в зависимости от выбора пользователя.
2. Использует глобальную переменную result для хранения результата вычислений.
3. Функция rectangle() рассчитывает площадь прямоугольника, а triangle() — площадь треугольника.
4. Выбор фигуры производится через пользовательский ввод (1 для прямоугольника, 2 для треугольника).
5. Демонстрирует использование глобальных переменных и функций для выполнения вычислений на основе пользовательского ввода.

## Самостоятельная работа №1
### Дайте подробный комментарий для кода, написанного ниже.
Комментарий нужен для каждой строчки кода, нужно описать что она
делает. Не забудьте, что функции комментируются по-особенному.

```python
from datetime import datetime  # Импортируем модуль datetime для работы с датой и временем
from math import sqrt  # Импортируем функцию sqrt из модуля math для вычисления квадратного корня

def main(**kwargs):
    """
    Функция принимает произвольное количество именованных аргументов (ключ-значение) в виде списков.
    Для каждого аргумента вычисляет квадратный корень суммы квадратов двух элементов списка и выводит результат.

    Аргументы:
    **kwargs: Набор именованных аргументов в виде словаря, где ключи - имена, а значения - списки с двумя числами.

    Возвращаемое значение:
    Нет явного возвращаемого значения, функция выводит результаты вычислений.
    """
    for key in kwargs.items():  # Перебираем все элементы (пары ключ-значение) из словаря kwargs
        result = sqrt(key[1][0] ** 2 + key[1][1] ** 2)  # Вычисляем квадратный корень суммы квадратов двух элементов списка
        print(result)  # Выводим результат вычисления

if __name__ == '__main__':  # Проверяем, выполняется ли скрипт напрямую
    start_time = datetime.now()  # Фиксируем текущее время для измерения времени выполнения программы

    main(  # Вызываем функцию main с набором именованных аргументов
        one=[10, 3],  # Передаем список [10, 3] под ключом 'one'
        two=[5, 4],  # Передаем список [5, 4] под ключом 'two'
        three=[15, 13],  # Передаем список [15, 13] под ключом 'three'
        four=[93, 53],  # Передаем список [93, 53] под ключом 'four'
        five=[133, 15],  # Передаем список [133, 15] под ключом 'five'
    )

    time_costs = datetime.now() - start_time  # Вычисляем время выполнения программы
    print(f"Время выполнения программы - {time_costs}")  # Выводим время, затраченное на выполнение программы
```
### Результат.
![image](https://github.com/user-attachments/assets/c32c62df-f67c-4df6-8cd2-1f0f57189c5c)

## Выводы
1. Импорт модулей: Программа импортирует datetime из модуля datetime для работы с датой и временем и sqrt из модуля math для вычисления квадратного корня.
2. Функция main:
Принимает произвольное количество именованных аргументов (**kwargs) в виде словаря, где ключи — строки, а значения — списки из двух чисел.
Для каждого элемента словаря:
Вычисляет квадратный корень суммы квадратов двух чисел из списка.
Выводит этот результат.
Документирована с использованием docstring, что помогает понять её назначение и структуру.
3. Главный блок программы:
Проверяет, выполняется ли программа напрямую (а не импортируется) с помощью if __name__ == '__main__':.
Фиксирует начальное время выполнения программы.
Вызывает функцию main с несколькими именованными аргументами (one, two, three, и т. д.), передавая им списки чисел.
После выполнения функции вычисляет и выводит время, затраченное на выполнение программы.
4. Цель: Программа демонстрирует:
Использование именованных аргументов (**kwargs) для передачи и обработки данных в функции.
Как использовать стандартные модули (datetime и math) для вычислений и измерения времени выполнения.
Как документировать функции в Python с помощью docstring и комментариев для обеспечения ясности и поддержки кода.
5. Вычисления: Основная операция — вычисление длины вектора по двум координатам (формула евклидовой нормы).
6. Итог: Программа наглядно показывает, как использовать различные инструменты Python для обработки данных, их вывода и измерения времени выполнения, а также правильное документирование кода.
  
## Самостоятельная работа №2
### Напишите программу, которая будет заменять игральную кость с 6
гранями. Если значение равно 5 или 6, то в консоль выводится «Вы
победили», если значения 3 или 4, то вы рекурсивно должны вызвать
эту же функцию, если значение 1 или 2, то в консоль выводится «Вы
проиграли». При этом каждый вызов функции необходимо выводить в
консоль значение “кубика”. Для выполнения задания необходимо 
использовать стандартную библиотеку random. Программу нужно
написать, используя одну функцию и “точку входа”

```python
from random import *


def game():
    random_num = randint(1, 6)
    print(f"Выпало число: {random_num}")
    if random_num == 5 or random_num == 6:
        print("Вы победили!")
    elif random_num == 4 or random_num == 3:
        game()
    else:
        print("вы проиграли!")
        
        
if __name__ == '__main__':
    game()
```

### Результат.
![image](https://github.com/user-attachments/assets/69b1b53f-2c47-4c4b-8caf-13a572b60c83)

## Выводы
1. Импорт библиотеки: Программа импортирует все функции из модуля random, однако фактически использует только randint() для генерации случайного числа от 1 до 6.
2. Функция game():
Генерирует случайное число от 1 до 6 и сохраняет его в переменную random_num.
Выводит выпавшее число.
Логика программы:
Если выпало число 5 или 6, выводит "Вы победили!" и завершает выполнение.
Если выпало число 3 или 4, рекурсивно вызывает функцию game(), повторяя игру.
Если выпало число 1 или 2, выводит "вы проиграли!" и завершает выполнение.
3. Рекурсивный вызов: Если выпадает 3 или 4, функция вызывает саму себя, что повторяет бросок кубика, пока не выпадет число 1, 2, 5, или 6.
4. Точка входа: Блок if __name__ == '__main__': запускает функцию game(), позволяя начать игру только при непосредственном выполнении скрипта.
5. Основная идея: Программа симулирует бросок игрального кубика и определяет победу или проигрыш в зависимости от выпавшего числа, используя рекурсию для продолжения игры в некоторых случаях.
  
## Самостоятельная работа №3
### Напишите программу, которая будет выводить текущее время, с
точностью до секунд на протяжении 5 секунд. Программу нужно
написать с использованием цикла. Подсказка: необходимо
использовать модуль datetime и time, а также вам необходимо как-то
“усыплять” программу на 1 секунду.

```python
from datetime import * 
from time import *


for i in range(5):
    current_time = datetime.now().strftime("%H:%M:%S")
    print(current_time)
    sleep(1)
```
### Результат.
![image](https://github.com/user-attachments/assets/912998c9-2ac6-4e56-85d4-3fd48727dcd3)

## Выводы
1. Импорт модулей:
Импортирует все функции из модулей datetime и time.
Используются только datetime.now() из datetime и sleep() из time.
2. Цикл for:
Цикл повторяется 5 раз, как указано в range(5).
В каждой итерации:
Получает текущее время с помощью datetime.now() и форматирует его в строку вида "ЧЧ:ММ:СС" с использованием strftime("%H:%M:%S").
Выводит текущее время.
Пауза на 1 секунду (sleep(1)), чтобы задержать выполнение перед следующей итерацией.
3. Основная идея:
Программа отображает текущее время 5 раз, с интервалом в 1 секунду между каждым выводом.
4. Использование:
Программа демонстрирует работу с текущим временем и задержку выполнения (sleep) для создания паузы.
  
## Самостоятельная работа №4
### Напишите программу, которая считает среднее арифметическое от
аргументов вызываемое функции, с условием того, что изначальное
количество этих аргументов неизвестно. Программу необходимо
реализовать используя одну функцию и “точку входа“.

```python
def main(*args):
    return sum(args) / float(len(args))


if __name__ == '__main__':
    result = main( 5, 6, 8, 11)
    print(f"Результат = {result}")
```
### Результат.
![image](https://github.com/user-attachments/assets/112e9aa2-2b48-42f9-a4c3-56048ece231c)

## Выводы
1. Программа вычисляет среднее арифметическое от произвольного количества аргументов, используя *args.
2. Функция main принимает неопределенное количество чисел, суммирует их и делит на количество для вычисления среднего.
3. Точка входа (if __name__ == '__main__') вызывает функцию с набором чисел и выводит результат.
4. Код универсален и позволяет передавать любое количество аргументов, как и требуется по заданию.
  
## Самостоятельная работа №5
### Создайте два Python файла, в одном будет выполняться вычисление
площади треугольника при помощи формулы Герона (необходимо
реализовать через функцию), а во втором будет происходить
взаимодействие с пользователем (получение всей необходимой
информации и вывод результатов). Напишите эту программу и
выведите в консоль полученную площадь.
## myself_rb5

```python
from math import *

def calculate(x, y, z):


    result1 = (x + y + z) / 2 
    result2 = sqrt(result1 * (result1 - x) * (result1 - y) * (result1 - z)) 
    return result2
```
## myself_rb5_1

```python
from myself_rb5 import calculate

if __name__ == '__main__':
    x = float(input("Введите длину первой стороны треугольника: "))
    y = float(input("Введите длину второй стороны треугольника: "))
    z = float(input("Введите длину третьей стороны треугольника: "))
    result2 = calculate(x, y, z)
    print(f"Площадь треугольника равна: {result2}")
```
### Результат.
![image](https://github.com/user-attachments/assets/bb3a4404-7615-4ee1-9725-39224a945c06)

## Выводы
1. Первая программа (myself_rb5.py):
Определяет функцию calculate(x, y, z), которая принимает длины трех сторон треугольника.
Вычисляет площадь треугольника с использованием формулы Герона и возвращает результат.
2. Вторая программа (myself_rb5_1.py):
Импортирует функцию calculate из модуля myself_rb5.
Запрашивает у пользователя длины сторон треугольника.
Вызывает функцию calculate для вычисления площади и выводит результат.
3. Основная идея:
Реализовано разделение кода: первая программа выполняет вычисление, а вторая обеспечивает взаимодействие с пользователем.
Программы корректно обрабатывают расчет площади треугольника по введенным сторонам.

## Общие выводы по теме
1. В этой теме я узнал многое об операторах, условиях и циклах
2. Так как это мой второй урок по программированию на python, он позволил мне расширить свои базовые знания и позволил мне, как выполнять примеры, так и приминить полученые знания на практике, как например в "Самостоятельной работе"
